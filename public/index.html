<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>Anton Liakhovitch: Embedded Software Engineer</title>
    <link rel="stylesheet" href="https://liakhovitch.github.io/public/global.css">
    <meta name="description" content="">
    <meta property="og:title" content="Anton Liakhovitch: Embedded Software Engineer">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    
    <meta property="og:url" content="https://liakhovitch.github.io/public/">
    <link rel="canonical" href="https://liakhovitch.github.io/public/">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@">
    <link rel="icon" href="">
    <meta name="theme-color" content="#1F1E1E">
  </head>
  <body>
    <header>
      <nav>
      
        <a href="/">HOME</a>
      
        <a href="https://github.com/liakhovitch">GITHUB</a>
      
        <a href="https://liakhovitch.github.io/resume/resume.pdf">RESUME</a>
      
      </nav>
      <hr>
    </header>
    <main>
      
  <h1 id="anton-liakhovitch">Anton Liakhovitch</h1>
<p><em>Engineer</em><br />
aeliakhovitch@gmail.com, 971-295-0315</p>
<hr />
<br/>
<h1 style="text-align: center;"><i>Projects</i></h1>
<br/>
<h2 id="cronch-not-entirely-sane-digital-delay-pedal">CRÖNCH: Not-Entirely-Sane Digital Delay Pedal</h2>
<p>Crönch is a hardware audio effects processor, inspired by the Sonic Charge Permut8 software plugin. The device is based on an RP2040 MCU and performs 192KHz audio processing in real time, while driving 76 LEDs and 48 switches with a second processor core. I assembled it by hand and soldered SMD components with a homemade oven. This project is currently on pause, but it still represents my best work to-date - especially the <a href="https://github.com/liakhovitch/cronch/blob/main/pcb/effectpedal/fabrication/schematic.pdf">schematic</a>. More info available on <a href="https://github.com/liakhovitch/cronch">Github</a>.</p>
<p><img src='public/images/cronch.jpg'><br/><br/></p>
<h2 id="undergrad-senior-capstone-can-logger">Undergrad Senior Capstone: CAN Logger</h2>
<p>I was part of a four-person team that developed an automotive diagnostic bus (CAN) logging appliance for Hyster-Yale inc. We worked on this in the middle of the parts shortage, so we chose a somewhat underpowered single-core Cortex M4 microcontroller due to its wide availability. As the firmware lead, I was tasked with developing performant real-time firmware that could make hard data integrity guarantees when receiving at maximum bus speed. More info (including a detailed technical report) available on the <a href="https://eecs.engineering.oregonstate.edu/project-showcase/projects/?id=gSDrxXntCfJTY05l">OSU EECS project showcase</a>.</p>
<p><img src='public/images/canlogger.jpg'><br/><br/></p>
<h2 id="junior-capstone-egg-timer">Junior Capstone: Egg Timer</h2>
<p>My junior capstone class tasked me with bringing a product from concept to prototype in ten weeks, by myself. I built a digital kitchen timer, with my very first custom PCB and a CNC-machined acrylic enclosure. The timer is based on the widely available STM32f103 32-bit MCU. I try to learn as much as possible from every academic project, so I wrote the firmware in Rust with the experimental (at the time) realtime interrupt-based concurrency (RTIC) framework. More info available on the <a href="https://eecs.engineering.oregonstate.edu/project-showcase/projects/?id=trLHRkyRlfQhVEzy">OSU EECS project showcase</a> and <a href="https://github.com/liakhovitch/junior_design">Github</a>.
<img src='public/images/eggtimer.jpg'><br/><br/></p>
<h2 id="microcontroller-system-design-class-another-clock">Microcontroller System Design Class: Another Clock</h2>
<p>This is an alarm clock (AVR, firmware in C) that I built for Dr. Roger Traylor's MCU System Design class in early 2023. We were tasked with developing a different part of the clock each week. Most students ended up with a fragile mess of three or more breadboards, but I planned ahead and used perfboard. This class effectively simulated a rapid prototyping environment with stringent and constantly expanding requirements. As per OSU policy, the firmware cannot be published but is available upon request.</p>
<p><img src='public/images/alarmclock.jpg'><br/>
<img src='public/images/spaghetti.jpg'><br/><br/></p>
<h2 id="hacking-an-iot-sensor">Hacking an IoT Sensor</h2>
<p>In my IT job at OSU, I came across a research group that was locked out of their $10,000 fleet of remote sensors when the manufacturer went bankrupt and shut down their cloud services. By the end of the day, I gained root access and restored functionality to the devices. The exploit involved a TFTP misconfiguration which made it possible to retrieve the hashed root password, and a weak root password that was easily crackable.</p>
<p><img src='public/images/sensor.jpg'><br/><br/></p>
<h2 id="google-bug-bounty">Google Bug Bounty</h2>
<p>I stumbled upon an issue where the Google Home mobile app would crash while setting up a Google Home smart speaker. After extensive toubleshooting, I determined that this only happened whenever a wireless network with a quotation symbol in the SSID was present. I recognized this as a potential zero-click code injection vulnerability, so I reported it to the bug bounty program and received a $500 reward.</p>
<p><img src='public/images/home.jpg'><br/><br/></p>
<h2 id="hoot-owl-shaped-emergency-radio">HOOT: Owl-Shaped Emergency Radio</h2>
<p>In early 2022, I made my friend a pair of owl-shaped LoRa radios as a housewarming present. Tapping one owl would make the other hoot, allowing for simple communication around the house (&quot;Hoot, dinner is ready!&quot;). In an emergency situation, the watertight electronics enclosures could be taken out of their owl shells and used to transmit morse code, or paired with a smartphone (via adhoc WiFi) to transmit text. HOOT is based on an ESP32 MCU with firmware in C, and implements LoRa communication, ad-hoc WiFi, a web server, speech synthesis, audio sample playback, and an integrated battery. This was all rapidly constructed over the course of one month. The hastily-written firmware is unfit for publication, but there is a <a href="public/hoot_manual.pdf">manual</a>.</p>
<p><img src='public/images/hoot.jpg'><br/><br/></p>
<h2 id="laser-tag-proximity-mine">Laser Tag Proximity Mine</h2>
<p>In 2018, I felt like experimenting with the FORTH programming language. I reverse-engineered the infrared communication protocol used by a set of Hasbro laser tag blasters, then made a compatible proximity mine. The mine includes features such as IFF beacon transmission, automatic detection of the user's team, configurable damage, and more. Firmware is available on <a href="https://github.com/liakhovitch/claymore">Github</a>.</p>
<p><img src='public/images/claymore.jpg'><br/><br/></p>
<h2 id="router-storage-expansion">Router Storage Expansion</h2>
<p>During my freshman year at OSU, I had a hobby of buying dirt-cheap used routers and repurposing them as general-purpose single-board computers. One particular device came with only 4MB of storage and no USB port. I found that the onboard SOC included USB support, so I glued an 8GB flash drive to the board and ran jumpers from the data pins directly to the SOC's QFN package. I then had to compile OpenWRT (a Linux distro for routers), with a custom kernel that included USB/storage drivers and practically nothing else. From there, I could set up the device to load further data from the flash drive.</p>
<p><img src='public/images/router.jpg'><br/><br/></p>


    </main>
  </body>
</html>
